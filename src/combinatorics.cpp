#include <vector>
#include <cmath>
#include "combinatorics.h"
using namespace std;


/**
 * Create all possible subsets of a set, known as a powerset
 * 
 * @param K : number of elements in the set
 * @returns matrix : a two dimensional matrix where
 * each row represents a subset and each column represents
 * an element. Zero and one indicate the the element is
 * excluded or included in the given subset, respectively.
*/
vector<vector<int>> create_powerset(int K)
{
    // Compute number of sets in powerset
    int N = std::pow(2, K);

    // Initialise
    vector<vector<int>> matrix(
        N,
        vector<int>(K));

    // Populate
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < K; ++j) {
            int val = i / pow(2, j);
            if (val % 2) {
                matrix[i][j] = 1;
            }
        }
    }

    return matrix;
}

/**
 * Create all possible partitions of a set
 * 
 * The total number of possible partitions is given by the
 * Bell number. Partitions are generated recursively: given
 * all possible partitions of a set of size `n`; the partitions
 * for a set of size `n + 1` are generated by inserting the additional
 * element (1) in all subsets for each previous partition; (2) as its
 * own subset for each previous partition.
 * 
 * @param collection : elements in the set, restricted to integers
 * @returns n1_partitions : a vector of possible partitions of the set. 
 * Each possible partition is represented by a vector, and within each partition
 * grouped subsets are also vectors. 
*/
vector<vector<vector<int>>> create_all_partitions(vector<int> collection)
{
    // A set of one element has only one partition
    if (collection.size() == 1) {
        vector<vector<vector<int>>> n1_partitions(
            1, vector<vector<int>>(
            1, vector<int>(
            1)
            )
        );
        n1_partitions[0][0][0] = collection[0];
        return n1_partitions;
    }

    // A set of n + 1 elements is created recurisvely
    int elem = collection.front();
    collection.erase(collection.begin());

    vector<vector<vector<int>>> n_partitions = create_all_partitions(collection);
    vector<vector<vector<int>>> n1_partitions;
    
    for (vector<vector<int>> partition : n_partitions) {
        
        for (int i = 0; i < partition.size(); ++i) {
            vector<vector<int>> n1_partition = partition;
            n1_partition[i].push_back(elem);
            n1_partitions.push_back(n1_partition);
        }

        vector<vector<int>> n1_partition = partition;
        vector<int> only_elem_subset;
        only_elem_subset.push_back(elem);
        n1_partition.push_back(only_elem_subset);
        n1_partitions.push_back(n1_partition);
    }

    return n1_partitions;
}